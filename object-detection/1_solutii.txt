# E1

mask_tensor = pil_to_tensor(mask)[0]  # scoatem doar canalul
ys, xs = torch.where(mask_tensor == 3)
if len(xs) == 0:
	return None
xmin, xmax = xs.min().item(), xs.max().item()
ymin, ymax = ys.min().item(), ys.max().item()

# E2
xmin, ymin, xmax, ymax = box
w = xmax - xmin
h = ymax - ymin
x_center = xmin + w / 2.0
y_center = ymin + h / 2.0
return [x_center / img_w, y_center / img_h, w / img_w, h / img_h]

# E3 
    x_center, y_center, w, h = box
    x_center *= img_w
    y_center *= img_h
    w *= img_w
    h *= img_h
    xmin = x_center - w / 2.0
    ymin = y_center - h / 2.0

# E4

    x1_min, y1_min, x1_max, y1_max = box1
    x2_min, y2_min, x2_max, y2_max = box2
    xi_min = max(x1_min, x2_min)
    yi_min = max(y1_min, y2_min)
    xi_max = min(x1_max, x2_max)
    yi_max = min(y1_max, y2_max)
    inter_w = max(0.0, xi_max - xi_min)
    inter_h = max(0.0, yi_max - yi_min)
    inter_area = inter_w * inter_h
    area1 = max(0.0, x1_max - x1_min) * max(0.0, y1_max - y1_min)
    area2 = max(0.0, x2_max - x2_min) * max(0.0, y2_max - y2_min)
    union_area = area1 + area2 - inter_area
    if union_area <= 0:
        return 0.0


    x1_min, y1_min, x1_max, y1_max = box1
    x2_min, y2_min, x2_max, y2_max = box2
    xi_min = max(x1_min, x2_min)
    yi_min = max(y1_min, y2_min)
    xi_max = min(x1_max, x2_max)
    yi_max = min(y1_max, y2_max)
    inter_w = max(0.0, xi_max - xi_min)
    inter_h = max(0.0, yi_max - yi_min)
    inter_area = inter_w * inter_h
    area1 = max(0.0, x1_max - x1_min) * max(0.0, y1_max - y1_min)
    area2 = max(0.0, x2_max - x2_min) * max(0.0, y2_max - y2_min)
    union_area = area1 + area2 - inter_area
    return (inter_area / union_area) if union_area > 0 else 0.0


# E5

    if len(boxes) == 0:
        return []

    boxes = boxes.astype(float)
    scores = scores.astype(float)

    # filtrare după scor (opțional)
    if score_threshold is not None:
        keep_mask = scores >= score_threshold
        boxes = boxes[keep_mask]
        scores = scores[keep_mask]
        if len(boxes) == 0:
            return []

        # Vom avea nevoie să mapăm înapoi indexurile originale
        original_idx = np.nonzero(keep_mask)[0]
    else:
        original_idx = np.arange(len(boxes))

    # sortare descendentă după scor
    order = np.argsort(-scores)
    keep_local = []

    x1 = boxes[:, 0]
    y1 = boxes[:, 1]
    x2 = boxes[:, 2]
    y2 = boxes[:, 3]

    # arii
    areas = np.clip(x2 - x1, 0, None) * np.clip(y2 - y1, 0, None)

    while order.size > 0:
        i = order[0]
        keep_local.append(i)
        if max_dets is not None and len(keep_local) >= max_dets:
            break

        # iou între boxa curentă și restul
        xx1 = np.maximum(x1[i], x1[order[1:]])
        yy1 = np.maximum(y1[i], y1[order[1:]])
        xx2 = np.minimum(x2[i], x2[order[1:]])
        yy2 = np.minimum(y2[i], y2[order[1:]])

        w = np.clip(xx2 - xx1, 0, None)
        h = np.clip(yy2 - yy1, 0, None)
        inter = w * h
        union = areas[i] + areas[order[1:]] - inter
        iou = np.where(union > 0, inter / union, 0.0)

        # păstrăm doar cutiile cu IoU <= prag (cele > prag se elimină)
        remain = np.where(iou <= iou_threshold)[0]
        order = order[remain + 1]

    # mapăm la indexurile originale
    keep = original_idx[np.array(keep_local, dtype=int)].tolist()
    return keep